package mcp

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/sirupsen/logrus"
)

// GitConfig holds Git repository configuration
type GitConfig struct {
	RepoPath    string `json:"repo_path"`
	RemoteURL   string `json:"remote_url"`
	Branch      string `json:"branch"`
	AutoCommit  bool   `json:"auto_commit"`
	AutoPush    bool   `json:"auto_push"`
	Enabled     bool   `json:"enabled"`
	CommitUser  string `json:"commit_user"`
	CommitEmail string `json:"commit_email"`
}

// GitManager handles Git operations for YAML files
type GitManager struct {
	config *GitConfig
}

// NewGitManager creates a new GitManager instance
func NewGitManager(config *GitConfig) *GitManager {
	if config == nil {
		config = &GitConfig{
			Enabled: false,
		}
	}

	// Set defaults
	if config.Branch == "" {
		config.Branch = "main"
	}
	if config.CommitUser == "" {
		config.CommitUser = "openshift-mcp-bot"
	}
	if config.CommitEmail == "" {
		config.CommitEmail = "openshift-mcp-bot@example.com"
	}

	return &GitManager{
		config: config,
	}
}

// IsEnabled returns whether Git integration is enabled
func (g *GitManager) IsEnabled() bool {
	return g.config.Enabled && g.config.RepoPath != ""
}

// InitializeRepo initializes the Git repository if it doesn't exist
func (g *GitManager) InitializeRepo() error {
	if !g.IsEnabled() {
		return nil
	}

	// Create directory if it doesn't exist
	if err := os.MkdirAll(g.config.RepoPath, 0755); err != nil {
		return fmt.Errorf("failed to create repo directory: %v", err)
	}

	// Check if it's already a Git repository
	if _, err := os.Stat(filepath.Join(g.config.RepoPath, ".git")); os.IsNotExist(err) {
		// Initialize Git repository
		if err := g.runGitCommand("init"); err != nil {
			return fmt.Errorf("failed to initialize Git repository: %v", err)
		}

		// Configure Git user
		if err := g.runGitCommand("config", "user.name", g.config.CommitUser); err != nil {
			return fmt.Errorf("failed to configure Git user: %v", err)
		}

		if err := g.runGitCommand("config", "user.email", g.config.CommitEmail); err != nil {
			return fmt.Errorf("failed to configure Git email: %v", err)
		}

		// Add remote if specified
		if g.config.RemoteURL != "" {
			if err := g.runGitCommand("remote", "add", "origin", g.config.RemoteURL); err != nil {
				logrus.Warnf("Failed to add remote: %v", err)
			}
		}

		// Create initial commit
		readmeContent := fmt.Sprintf(`# OpenShift MCP Generated YAML Files

This repository contains YAML files generated by OpenShift MCP server.

Generated on: %s
`, time.Now().Format("2006-01-02 15:04:05"))

		readmePath := filepath.Join(g.config.RepoPath, "README.md")
		if err := os.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
			return fmt.Errorf("failed to create README: %v", err)
		}

		if err := g.runGitCommand("add", "README.md"); err != nil {
			return fmt.Errorf("failed to add README: %v", err)
		}

		if err := g.runGitCommand("commit", "-m", "Initial commit - OpenShift MCP YAML repository"); err != nil {
			return fmt.Errorf("failed to create initial commit: %v", err)
		}

		logrus.Infof("Initialized Git repository at %s", g.config.RepoPath)
	}

	return nil
}

// SaveYAMLFile saves a YAML file to the repository
func (g *GitManager) SaveYAMLFile(filename, content, action, description string) (string, error) {
	if !g.IsEnabled() {
		return "", fmt.Errorf("Git integration is disabled")
	}

	// Create subdirectory based on action
	actionDir := filepath.Join(g.config.RepoPath, "actions", action)
	if err := os.MkdirAll(actionDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create action directory: %v", err)
	}

	// Add timestamp to filename to avoid conflicts
	timestamp := time.Now().Format("20060102-150405")
	filename = fmt.Sprintf("%s-%s.yaml", timestamp, filename)
	filePath := filepath.Join(actionDir, filename)

	// Write YAML content to file
	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		return "", fmt.Errorf("failed to write YAML file: %v", err)
	}

	logrus.Infof("Saved YAML file: %s", filePath)

	// Auto-commit if enabled
	if g.config.AutoCommit {
		if err := g.commitFile(filePath, action, description); err != nil {
			logrus.Warnf("Failed to auto-commit: %v", err)
		}
	}

	return filePath, nil
}

// commitFile commits a single file to the repository
func (g *GitManager) commitFile(filePath, action, description string) error {
	// Add file to Git
	relPath, err := filepath.Rel(g.config.RepoPath, filePath)
	if err != nil {
		return fmt.Errorf("failed to get relative path: %v", err)
	}

	if err := g.runGitCommand("add", relPath); err != nil {
		return fmt.Errorf("failed to add file to Git: %v", err)
	}

	// Create commit message
	commitMsg := fmt.Sprintf("Add %s: %s", action, description)
	if err := g.runGitCommand("commit", "-m", commitMsg); err != nil {
		return fmt.Errorf("failed to commit file: %v", err)
	}

	logrus.Infof("Committed file: %s", relPath)

	// Auto-push if enabled
	if g.config.AutoPush && g.config.RemoteURL != "" {
		if err := g.pushToRemote(); err != nil {
			logrus.Warnf("Failed to auto-push: %v", err)
		}
	}

	return nil
}

// pushToRemote pushes changes to the remote repository
func (g *GitManager) pushToRemote() error {
	if err := g.runGitCommand("push", "origin", g.config.Branch); err != nil {
		return fmt.Errorf("failed to push to remote: %v", err)
	}

	logrus.Infof("Pushed changes to remote repository")
	return nil
}

// runGitCommand executes a Git command in the repository directory
func (g *GitManager) runGitCommand(args ...string) error {
	cmd := exec.Command("git", args...)
	cmd.Dir = g.config.RepoPath

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("git command failed: %v, output: %s", err, string(output))
	}

	logrus.Debugf("Git command executed: git %s", strings.Join(args, " "))
	return nil
}

// GetStatus returns the Git repository status
func (g *GitManager) GetStatus() (string, error) {
	if !g.IsEnabled() {
		return "Git integration is disabled", nil
	}

	cmd := exec.Command("git", "status", "--porcelain")
	cmd.Dir = g.config.RepoPath

	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to get Git status: %v", err)
	}

	return string(output), nil
}

// ListFiles returns a list of YAML files in the repository
func (g *GitManager) ListFiles() ([]string, error) {
	if !g.IsEnabled() {
		return []string{}, nil
	}

	var files []string

	err := filepath.Walk(g.config.RepoPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() && strings.HasSuffix(path, ".yaml") {
			relPath, err := filepath.Rel(g.config.RepoPath, path)
			if err != nil {
				return err
			}
			files = append(files, relPath)
		}

		return nil
	})

	return files, err
}

// CommitAllChanges commits all pending changes
func (g *GitManager) CommitAllChanges(message string) error {
	if !g.IsEnabled() {
		return fmt.Errorf("Git integration is disabled")
	}

	// Add all changes
	if err := g.runGitCommand("add", "."); err != nil {
		return fmt.Errorf("failed to add changes: %v", err)
	}

	// Commit changes
	if err := g.runGitCommand("commit", "-m", message); err != nil {
		return fmt.Errorf("failed to commit changes: %v", err)
	}

	logrus.Infof("Committed all changes: %s", message)
	return nil
}

// PushChanges pushes all changes to remote repository
func (g *GitManager) PushChanges() error {
	if !g.IsEnabled() {
		return fmt.Errorf("Git integration is disabled")
	}

	if g.config.RemoteURL == "" {
		return fmt.Errorf("no remote URL configured")
	}

	return g.pushToRemote()
}

// CreateArgocdDirectoryStructure creates the ArgoCD-compatible directory structure
func (g *GitManager) CreateArgocdDirectoryStructure() error {
	if !g.config.Enabled {
		return nil
	}

	dirs := []string{
		"applications",     // ArgoCD Application definitions
		"environments/dev", // Environment-specific configurations
		"environments/staging",
		"environments/prod",
		"manifests/base",         // Base Kubernetes manifests
		"manifests/overlays/dev", // Environment-specific overlays
		"manifests/overlays/staging",
		"manifests/overlays/prod",
		"components", // Reusable components
		"config",     // Configuration files
		"scripts",    // Utility scripts
	}

	for _, dir := range dirs {
		fullPath := filepath.Join(g.config.RepoPath, dir)
		if err := os.MkdirAll(fullPath, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %v", fullPath, err)
		}
	}

	// Create .gitkeep files to preserve empty directories
	for _, dir := range dirs {
		gitkeepPath := filepath.Join(g.config.RepoPath, dir, ".gitkeep")
		if _, err := os.Stat(gitkeepPath); os.IsNotExist(err) {
			if err := os.WriteFile(gitkeepPath, []byte(""), 0644); err != nil {
				logrus.Warnf("Failed to create .gitkeep in %s: %v", dir, err)
			}
		}
	}

	return nil
}

// SaveArgocdApplication saves an ArgoCD Application YAML file
func (g *GitManager) SaveArgocdApplication(name, yamlContent string) error {
	if !g.config.Enabled {
		return nil
	}

	filename := fmt.Sprintf("%s-application", name)
	_, err := g.SaveYAMLFile(filename, yamlContent, "argocd", "ArgoCD Application")
	return err
}

// SaveArgocdManifest saves a Kubernetes manifest to the appropriate directory
func (g *GitManager) SaveArgocdManifest(appName, environment, manifestType, yamlContent string) error {
	if !g.config.Enabled {
		return nil
	}

	var dir string
	if environment == "" || environment == "base" {
		dir = filepath.Join(g.config.RepoPath, "manifests", "base", appName)
	} else {
		dir = filepath.Join(g.config.RepoPath, "manifests", "overlays", environment, appName)
	}

	// Create app-specific directory if it doesn't exist
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %v", dir, err)
	}

	filename := fmt.Sprintf("%s.yaml", manifestType)
	filePath := filepath.Join(dir, filename)

	// Write YAML content to file
	if err := os.WriteFile(filePath, []byte(yamlContent), 0644); err != nil {
		return fmt.Errorf("failed to write manifest file: %v", err)
	}

	logrus.Infof("Saved ArgoCD manifest: %s", filePath)
	return nil
}

// SaveArgocdManifestBundle saves a complete manifest bundle with kustomization
func (g *GitManager) SaveArgocdManifestBundle(appName, environment string, manifests map[string]string) error {
	if !g.config.Enabled {
		return nil
	}

	var dir string
	if environment == "" || environment == "base" {
		dir = filepath.Join(g.config.RepoPath, "manifests", "base", appName)
	} else {
		dir = filepath.Join(g.config.RepoPath, "manifests", "overlays", environment, appName)
	}

	// Create app-specific directory if it doesn't exist
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %v", dir, err)
	}

	// Save all manifests
	for filename, content := range manifests {
		filePath := filepath.Join(dir, filename)
		if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
			return fmt.Errorf("failed to save %s: %v", filename, err)
		}
	}

	logrus.Infof("Saved ArgoCD manifest bundle for %s in %s", appName, dir)
	return nil
}

// SaveArgocdEnvironmentConfig saves environment-specific configuration
func (g *GitManager) SaveArgocdEnvironmentConfig(environment, configType, yamlContent string) error {
	if !g.config.Enabled {
		return nil
	}

	dir := filepath.Join(g.config.RepoPath, "environments", environment)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %v", dir, err)
	}

	filename := fmt.Sprintf("%s.yaml", configType)
	filePath := filepath.Join(dir, filename)

	// Write YAML content to file
	if err := os.WriteFile(filePath, []byte(yamlContent), 0644); err != nil {
		return fmt.Errorf("failed to write environment config file: %v", err)
	}

	logrus.Infof("Saved environment config: %s", filePath)
	return nil
}

// GenerateArgocdAppOfApps generates an App of Apps manifest for a given environment
func (g *GitManager) GenerateArgocdAppOfApps(environment, repoURL string, applications []string) (string, error) {
	yamlGen := NewYAMLGenerator()

	appOfAppsName := fmt.Sprintf("%s-apps", environment)
	appOfAppsPath := fmt.Sprintf("applications/%s", environment)

	return yamlGen.GenerateArgoCDAppOfAppsYAML(appOfAppsName, "argocd", repoURL, appOfAppsPath, applications)
}

// SaveArgocdAppOfApps saves an App of Apps manifest
func (g *GitManager) SaveArgocdAppOfApps(environment, yamlContent string) error {
	if !g.config.Enabled {
		return nil
	}

	filename := fmt.Sprintf("%s-apps.yaml", environment)
	filePath := filepath.Join(g.config.RepoPath, "applications", filename)

	// Write YAML content to file
	if err := os.WriteFile(filePath, []byte(yamlContent), 0644); err != nil {
		return fmt.Errorf("failed to write app of apps file: %v", err)
	}

	logrus.Infof("Saved App of Apps: %s", filePath)
	return nil
}

// ListArgocdApplications lists all ArgoCD applications in the repository
func (g *GitManager) ListArgocdApplications() ([]string, error) {
	if !g.config.Enabled {
		return nil, fmt.Errorf("git is not enabled")
	}

	appsDir := filepath.Join(g.config.RepoPath, "applications")
	files, err := os.ReadDir(appsDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read applications directory: %v", err)
	}

	var applications []string
	for _, file := range files {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".yaml") {
			applications = append(applications, file.Name())
		}
	}

	return applications, nil
}

// GetArgocdApplicationManifests gets all manifests for a specific application
func (g *GitManager) GetArgocdApplicationManifests(appName, environment string) (map[string]string, error) {
	if !g.config.Enabled {
		return nil, fmt.Errorf("git is not enabled")
	}

	var dir string
	if environment == "" || environment == "base" {
		dir = filepath.Join(g.config.RepoPath, "manifests", "base", appName)
	} else {
		dir = filepath.Join(g.config.RepoPath, "manifests", "overlays", environment, appName)
	}

	files, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("failed to read manifests directory: %v", err)
	}

	manifests := make(map[string]string)
	for _, file := range files {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".yaml") {
			filePath := filepath.Join(dir, file.Name())
			content, err := os.ReadFile(filePath)
			if err != nil {
				logrus.Warnf("Failed to read file %s: %v", filePath, err)
				continue
			}
			manifests[file.Name()] = string(content)
		}
	}

	return manifests, nil
}

// CommitArgocdChanges commits changes with ArgoCD-specific message format
func (g *GitManager) CommitArgocdChanges(appName, environment, action, message string) error {
	if !g.config.Enabled {
		return nil
	}

	commitMessage := fmt.Sprintf("[%s] %s %s", environment, action, appName)
	if message != "" {
		commitMessage = fmt.Sprintf("%s: %s", commitMessage, message)
	}

	return g.CommitAllChanges(commitMessage)
}

// SyncArgocdApplication triggers a sync for ArgoCD application (placeholder for future webhook integration)
func (g *GitManager) SyncArgocdApplication(appName, environment string) error {
	if !g.config.Enabled {
		return nil
	}

	// This is a placeholder for future ArgoCD webhook integration
	// For now, it just logs the sync request
	logrus.Infof("ArgoCD sync requested for application %s in environment %s", appName, environment)

	// In a real implementation, this would call ArgoCD API or webhook
	// to trigger application synchronization

	return nil
}

// ValidateArgocdRepository checks if the repository has the correct ArgoCD structure
func (g *GitManager) ValidateArgocdRepository() error {
	if !g.config.Enabled {
		return nil
	}

	requiredDirs := []string{
		"applications",
		"environments",
		"manifests/base",
		"manifests/overlays",
	}

	for _, dir := range requiredDirs {
		fullPath := filepath.Join(g.config.RepoPath, dir)
		if _, err := os.Stat(fullPath); os.IsNotExist(err) {
			return fmt.Errorf("required ArgoCD directory %s does not exist", dir)
		}
	}

	return nil
}

// CleanupArgocdManifests removes orphaned manifests for deleted applications
func (g *GitManager) CleanupArgocdManifests(activeApps []string) error {
	if !g.config.Enabled {
		return nil
	}

	activeAppMap := make(map[string]bool)
	for _, app := range activeApps {
		activeAppMap[app] = true
	}

	environments := []string{"base", "dev", "staging", "prod"}

	for _, env := range environments {
		var manifestsDir string
		if env == "base" {
			manifestsDir = filepath.Join(g.config.RepoPath, "manifests", "base")
		} else {
			manifestsDir = filepath.Join(g.config.RepoPath, "manifests", "overlays", env)
		}

		if _, err := os.Stat(manifestsDir); os.IsNotExist(err) {
			continue
		}

		files, err := os.ReadDir(manifestsDir)
		if err != nil {
			logrus.Warnf("Failed to read manifests directory %s: %v", manifestsDir, err)
			continue
		}

		for _, file := range files {
			if file.IsDir() && !activeAppMap[file.Name()] {
				orphanPath := filepath.Join(manifestsDir, file.Name())
				logrus.Infof("Removing orphaned manifest directory: %s", orphanPath)
				if err := os.RemoveAll(orphanPath); err != nil {
					logrus.Warnf("Failed to remove orphaned directory %s: %v", orphanPath, err)
				}
			}
		}
	}

	return nil
}
